(require "game/structs.glsp")
(require "game/utils.glsp")
(require "game/ecs.glsp")
(require "game/systems.glsp")
(require "game/map.glsp")

(defn draw-map (map)
  (let x 0)
  (let y 0)
  (for tile in [map 'tiles]
    (match tile
      ('floor
        (set x y \. (Color 0.2 0.2 0.2) (Color 0 0 0)))
      ('wall
        (set x y \# (Color 0.5 0.5 0.5) (Color 0 0 0))))
    ; move coords
    (inc! x)
    (when (> x (- :width 1))
      (= x 0)
      (inc! y))))

; input manager
(defn player-input ()
  (let player (.fetch world 'player))
  (let pos (.get-cmp world player Position))
  (when (key? "up") (try-move-player 0 -1))
  (when (key? "down") (try-move-player 0 1))
  (when (key? "left") (try-move-player -1 0))
  (when (key? "right") (try-move-player 1 0))
  (when (key? "escape") (exit)))

(defn try-move-player (dx dy)
  (let player (.fetch world 'player))
  (let tiles [(.fetch world 'map) 'tiles])
  (let pos (.get-cmp world player Position))
  (let destination (xy-idx (+ [pos 'x] dx) (+ [pos 'y] dy)))
  ; block movement on walls
  (unless (eq? [tiles destination] 'wall)
    (= [pos 'x] (min 79 (max 0 (+ [pos 'x] dx))))
    (= [pos 'y] (min 49 (max 0 (+ [pos 'y] dy))))))

;;;;
;;;; logic starts here
;;;;

; init world
(def world (World))

; init the map
(let map (new-map-rooms-and-corridors))
(.save world 'map map)

; init player and save its ref
(let (px py) (.center (-> map ['rooms] [0])))
(let player (.add-entity world
  (Player)
  (.simple Renderable \@)
  (Position:new px py)))
(.save world 'player player)

(defn run ()
  ;(cls)
  (player-input)
  (draw-map (.fetch world 'map))
  (sys:render world))
