(load "game/components.glsp")
(load "game/utils.glsp")
(load "game/systems/index.glsp")
(load "game/map.glsp")
(load "game/player.glsp")


(defclass GameState
  (fsm
    ; all the work that needs to be done once per turn
    (state* Running
      (met on-step (world)
        (sys:render world)
        (sys:visibility world)
        (sys:monster-ai world)
        (@enab! 'Paused)))

    ; what's happening when we wait for an input
    (state Paused
      (met on-step (world)
        (let pressed (player-input world))
        (when pressed
          (@enab! 'Running))))))

;;
;; entry point
;;
(defn main:init ()
  ; init the global world
  ; (def :world (World))
  (def :world (World2))
  (def :state (GameState))

  ; init the map
  (let map (new-map-rooms-and-corridors))
  (.save :world 'map map)

  ; init player and save its ref
  (let rooms (.get-rooms map))
  (let (px py) (.center [rooms 0]))
  (let player
    (add-entity
      :world
      (Player)
      (Renderable (glyph \@)  (fg (Color 1 1 1)) (bg (Color 0 0 0)))
      (Position (x px) (y py))
      (Viewshed (visible-tiles (arr)) (range 8) (dirty #t))))
  (.save :world 'player player)

  ; init the monsters
  (for room in (skip 1 rooms)
    (let (x y) (.center room))
    (add-entity
      :world
      (Position x y)
      (Renderable (glyph \g) (fg (Color 1 0 0)) (bg (Color 0 0 0)))
      (Viewshed (visible-tiles (arr)) (range 8) (dirty #t))
      (Monster))))


;;
;; update called every tick
;;
(defn main:update ()
  (.on-step :state :world)
  (cls)
  (draw-map (.fetch :world 'map))
  (sys:render :world))
