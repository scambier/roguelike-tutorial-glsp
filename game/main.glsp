(load "game/components.glsp")
(load "game/utils.glsp")
(load "game/ecs.glsp")
(load "game/systems.glsp")
(load "game/map.glsp")
(load "game/rect.glsp")

; input manager
(defn player-input ()
  (let
    player (.fetch world 'player)
    pos (.get-cmp world player Position)
    map (.fetch world 'map))

  (when (key? "up") (try-move-player map 0 -1))
  (when (key? "down") (try-move-player map 0 1))
  (when (key? "left") (try-move-player map -1 0))
  (when (key? "right") (try-move-player map 1 0))
  (when (key? "escape") (exit)))


(defn try-move-player (map dx dy)
  (let
    player (.fetch world 'player)
    pos (.get-cmp world player Position)
    destination (.xy-idx map (+ [pos 'x] dx) (+ [pos 'y] dy)))

  ; block movement on walls
  (unless (eq? (-> [map 'tiles] [destination]) 'wall)
    (= [pos 'x] (min (- [map 'width] 1) (max 0 (+ [pos 'x] dx))))
    (= [pos 'y] (min (- [map 'height] 1) (max 0 (+ [pos 'y] dy))))))


;;
;; entry point
;;
(defn main:init ()
  ; init the global world
  (def world (World))

  ; init the map
  (let map (new-map-rooms-and-corridors))
  (.save world 'map map)

  ; init player and save its ref
  (let (px py) (.center (-> map ['rooms] [0])))
  (let player (.add-entity world
    (Player)
    (.simple Renderable \@)
    (Position:new px py)
    (Viewshed:new (arr) 8)))
  (.save world 'player player))


;;
;; update called every tick
;;
(defn main:update ()
  (cls)
  (player-input)
  ;(draw-map (.fetch world 'map))
  (let tiles [(.fetch world 'map) 'tiles])
  (draw-tiles tiles)
  (sys:render world))
