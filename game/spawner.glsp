(def MAX-MONSTERS 4)
(def MAX-ITEMS 2)

;; player

(defn spawner:player (x y)
  (ecs:spawn
    (Player)
    (Name (name "Player"))
    (Renderable (glyph \@)  (fg (Color 1 1 1)) (bg (Color 0 0 0)))
    (Position (x x) (y y))
    (Viewshed (visible-tiles (arr)) (range 9) (dirty #t))
    (CombatStats (max-hp 30) (hp 30) (defense 2) (power 5))))

(defn spawner:orc (x y)
  (spawner:monster x y \o "Orc"))

;; monsters

(defn spawner:goblin (x y)
  (spawner:monster x y \g "Goblin"))

(defn spawner:random-monster (x y)
  (match (rng:dice 1 2)
    (1 (spawner:orc x y))
    (_ (spawner:goblin x y))))

(defn spawner:monster (x y glyph name)
  (ecs:spawn
    (Position x y)
    (Renderable (glyph glyph) (fg (Color 1 0 0)) (bg (Color 0 0 0)))
    (Viewshed (visible-tiles (arr)) (range 8) (dirty #t))
    (Name (name name))
    (Monster)
    (BlocksTile)
    (CombatStats (max-hp 16) (hp 16) (defense 1) (power 4))))

;; map

(defn spawner:room (room)
  (let map (ecs:fetch 'map))
  (let spawn-points (arr))
  (let num-monsters (- (rng:dice 1 (+ MAX-MONSTERS 2)) 3))

  ;; try random positions to place monsters
  ;; while the new position isn't free
  (forn (i 0 num-monsters)
    (let added #n)
    (while (not added)
      (let x (+ [room 'x1] (rng:dice 1 [room 'width])))
      (let y (+ [room 'y1] (rng:dice 1 [room 'height])))
      (let idx (.xy-idx map x y))
      (unless (arr-contains? spawn-points idx)
        (push! spawn-points idx)
        (= added #t))))

  (for idx in spawn-points
    (let pos (.idx-xy map idx))
    (spawner:random-monster [pos 'x] [pos 'y])))
