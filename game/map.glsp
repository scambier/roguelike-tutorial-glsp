(defclass Map
  (field tiles)
  (field rooms)
  (field width)
  (field height)


  (init (@width @height)
    (= @tiles (arr-from-elem 'wall (* @width @height)))
    (= @rooms (arr)))


  (met xy-idx (x y)
    (+ (* y @width) x))


  (met apply-room-to-map (room)
    (forni (y (+ 1 [room 'y1]) [room 'y2])
      (forni (x (+ 1 [room 'x1]) [room 'x2])
        (= [@tiles (@xy-idx x y)] 'floor))))


  (met apply-horizontal-tunnel (x1 x2 y)
    (forni (x (min x1 x2) (max x1 x2))
      (let idx (@xy-idx x y))
      ; keep corridor within map range
      (when (and (> idx 0) (< idx (* @width @height)))
        (= [@tiles idx] 'floor))))


  (met apply-vertical-tunnel (y1 y2 x)
    (forni (y (min y1 y2) (max y1 y2))
      (let idx (@xy-idx x y))
      ; keep corridor within map range
      (when (and (> idx 0) (< idx (* @width @height)))
        (= [@tiles idx] 'floor)))))


(defn new-map-rooms-and-corridors ()
  (let
    map (Map :width :height),
    max-rooms 30, min-size 6, max-size 10,
    rng (RNG))

  (forn (_ 0 max-rooms)
    (let
      w (.range rng min-size max-size)
      h (.range rng min-size max-size)
      x (- (.roll-dice rng 1 (- [map 'width] w 1)) 1)
      y (- (.roll-dice rng 1 (- [map 'height] h 1)) 1)
      new-room (Rect x y w h)
      ok #t)

    (for other_room in [map 'rooms]
      (when (.intersect? new-room other_room) (= ok #f)))

    (when ok
      (.apply-room-to-map map new-room)
      (unless (empty? [map 'rooms])
        (let
          (new-x new-y) (.center new-room)
          (prev-x prev-y) (.center (last-item [map 'rooms])))

        (if (eq? (.range rng 0 2) 1)
          (do
            (.apply-horizontal-tunnel map prev-x new-x prev-y)
            (.apply-vertical-tunnel map prev-y new-y new-x))

          (do
            (.apply-vertical-tunnel map prev-y new-y prev-x)
            (.apply-horizontal-tunnel map prev-x new-x new-y))))


      (push! [map 'rooms] new-room)))
  map)

;
; utils
;

; (defn apply-room-to-map (room map)
;   (forni (y (+ 1 [room 'y1]) [room 'y2])
;     (forni (x (+ 1 [room 'x1]) [room 'x2])
;       (= [map (xy-idx x y)] 'floor))))

; (defn apply-horizontal-tunnel (map x1 x2 y)
;   (forni (x (min x1 x2) (max x1 x2))
;     (let idx (xy-idx x y))
;     ; keep corridor within map range
;     (when (and (> idx 0) (< idx (* :width :height)))
;       (= [map idx] 'floor))))

; (defn apply-vertical-tunnel (map y1 y2 x)
;   (forni (y (min y1 y2) (max y1 y2))
;     (let idx (xy-idx x y))
;     ; keep corridor within map range
;     (when (and (> idx 0) (< idx (* :width :height)))
;       (= [map idx] 'floor))))
