(defclass World
  (field counter)
  (field entities)
  (field resources)

  (init ()
    (= @counter 0)
    (= @entities (tab))
    (= @resources (tab)))

  (met fetch (key)
    [@resources key])

  (met save (key val)
    (= [@resources key] val))

  (met add-entity (..components)
    (inc! @counter)
    (= [@entities @counter] components)
    @counter)

  ; query the world to get entities with corresponding components
  ; TODO: implement some caching
  (met query
    (..types)
    (let filtered
      (->>
        @entities
        ; get entities that match the required types
        (filter (fn (e) (arr-contains-arr? (map (fn (cmp) (class-of cmp)) [e 1]) types)))
        ; only keep the required components
        (map (fn (e) (arr [e 0] (filter (fn (c) (index-of types (class-of c))) [e 1]))))))

    ; put them in the correct order
    (let ordered (tab))
    (for (k v) in filtered
      (let o
        (sort (arr ..v)
          ; https://stackoverflow.com/a/44063445
          (fn (a b) (gt-lt (- (index-of types (class-of a)) (index-of types (class-of b)))))))
      (= [ordered k] o))
    ordered)

  ; TODO: accept syms as entities
  (met get-cmp (entity ..types)
    (let structs (arr))
    (for type in types
      (let components (iter [@entities entity]))
      (push! structs (find (fn (cmp) (eq? (class-of cmp) type)) components)))
    (if (> (len structs) 0) structs [structs 0])))
